/**
 * Sajari API
 * Sajari is a smart, highly-configurable, real-time search service that enables thousands of businesses worldwide to provide amazing search experiences on their websites, stores, and applications.
 *
 * The version of the OpenAPI document: v4beta1
 * Contact: support@sajari.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from "request";
import http from "http";

/* tslint:disable:no-unused-locals */
import { GatewayruntimeError1 } from "../model/gatewayruntimeError1";
import { GatewayruntimeError2 } from "../model/gatewayruntimeError2";
import { Sajariv4beta1Pipeline1 } from "../model/sajariv4beta1Pipeline1";
import { V4beta1GeneratePipelinesRequest } from "../model/v4beta1GeneratePipelinesRequest";
import { V4beta1GeneratePipelinesResponse } from "../model/v4beta1GeneratePipelinesResponse";
import { V4beta1ListPipelinesResponse } from "../model/v4beta1ListPipelinesResponse";
import { V4beta1SetDefaultPipelineRequest } from "../model/v4beta1SetDefaultPipelineRequest";
import { V4beta1SetDefaultVersionRequest } from "../model/v4beta1SetDefaultVersionRequest";

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from "../model/models";
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from "../model/models";

import { HttpError, RequestFile } from "./apis";

let defaultBasePath = "https://api-gateway.sajari.com";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum PipelinesApiApiKeys {}

export class PipelinesApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    BasicAuth: new HttpBasicAuth(),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: PipelinesApiApiKeys, value: string) {
    (this.authentications as any)[PipelinesApiApiKeys[key]].apiKey = value;
  }

  set username(username: string) {
    this.authentications.BasicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.BasicAuth.password = password;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * Create a new pipeline.  Pipelines are immutable once created. If you want to change a pipeline e.g. to add or change some steps, you need to create a new version of that pipeline.  To start using a new pipeline you need to update your record ingestion calls and/or your query calls to specify the new pipeline.  To create the pipeline from YAML, set the request\'s `Content-Type` header to `application/yaml` and submit the pipeline\'s YAML in the request body.
   * @summary Create pipeline
   * @param collectionId The collection to create the pipeline in, e.g. &#x60;my-collection&#x60;.
   * @param sajariv4beta1Pipeline1 The pipeline to create.
   */
  public async createPipeline(
    collectionId: string,
    sajariv4beta1Pipeline1: Sajariv4beta1Pipeline1,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: Sajariv4beta1Pipeline1 }> {
    const localVarPath =
      this.basePath +
      "/v4beta1/collections/{collection_id}/pipelines".replace(
        /{\w+}/,
        String(collectionId)
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json", "application/yaml"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling createPipeline."
      );
    }

    // verify required parameter 'sajariv4beta1Pipeline1' is not null or undefined
    if (
      sajariv4beta1Pipeline1 === null ||
      sajariv4beta1Pipeline1 === undefined
    ) {
      throw new Error(
        "Required parameter sajariv4beta1Pipeline1 was null or undefined when calling createPipeline."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        sajariv4beta1Pipeline1,
        "Sajariv4beta1Pipeline1"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Sajariv4beta1Pipeline1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Sajariv4beta1Pipeline1");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Generate basic record, query and autocomplete pipeline templates. Use these templates as a starting point for your collection\'s pipelines.  This call returns a set of pipelines that you can pass directly to the create pipeline call.  The generated templates can be returned in JSON, the default, or YAML. To return the generated pipelines in YAML, set the request\'s `Accept` header to `application/yaml`. The three pipelines in the YAML response are separated by three dashes (`---`).
   * @summary Generate pipelines
   * @param collectionId The collection, e.g. &#x60;my-collection&#x60;.
   * @param v4beta1GeneratePipelinesRequest
   */
  public async generatePipelines(
    collectionId: string,
    v4beta1GeneratePipelinesRequest: V4beta1GeneratePipelinesRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: V4beta1GeneratePipelinesResponse;
  }> {
    const localVarPath =
      this.basePath +
      "/v4beta1/collections/{collection_id}:generatePipelines".replace(
        /{\w+}/,
        String(collectionId)
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json", "application/yaml"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling generatePipelines."
      );
    }

    // verify required parameter 'v4beta1GeneratePipelinesRequest' is not null or undefined
    if (
      v4beta1GeneratePipelinesRequest === null ||
      v4beta1GeneratePipelinesRequest === undefined
    ) {
      throw new Error(
        "Required parameter v4beta1GeneratePipelinesRequest was null or undefined when calling generatePipelines."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        v4beta1GeneratePipelinesRequest,
        "V4beta1GeneratePipelinesRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: V4beta1GeneratePipelinesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(
              body,
              "V4beta1GeneratePipelinesResponse"
            );
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Retrieve the details of a pipeline. Supply the type, name and version.  To retrieve the pipeline in YAML, set the request\'s `Accept` header to `application/yaml`.
   * @summary Get pipeline
   * @param collectionId The collection that owns the pipeline, e.g. &#x60;my-collection&#x60;.
   * @param type The type of the pipeline to retrieve, either &#x60;record&#x60; or &#x60;query&#x60;.
   * @param name The name of the pipeline to retrieve, e.g. &#x60;my-pipeline&#x60;.
   * @param version The version of the pipeline to retrieve, e.g. &#x60;42&#x60;.
   * @param view The amount of information to include in the retrieved pipeline.   - VIEW_UNSPECIFIED: The default / unset value. The API defaults to the &#x60;BASIC&#x60; view.  - BASIC: Include basic information including type, name, version and description but not the full step configuration. This is the default value (for both [ListPipelines](/docs/api-reference#operation/ListPipelines) and [GetPipeline](/docs/api-reference#operation/GetPipeline)).  - FULL: Include the information from &#x60;BASIC&#x60;, plus full step configuration.
   */
  public async getPipeline(
    collectionId: string,
    type: string,
    name: string,
    version: string,
    view?: "VIEW_UNSPECIFIED" | "BASIC" | "FULL",
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: Sajariv4beta1Pipeline1 }> {
    const localVarPath =
      this.basePath +
      "/v4beta1/collections/{collection_id}/pipelines/{type}/{name}/{version}"
        .replace(/{\w+}/, String(collectionId))
        .replace(/{\w+}/, String(type))
        .replace(/{\w+}/, String(name))
        .replace(/{\w+}/, String(version));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json", "application/yaml"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling getPipeline."
      );
    }

    // verify required parameter 'type' is not null or undefined
    if (type === null || type === undefined) {
      throw new Error(
        "Required parameter type was null or undefined when calling getPipeline."
      );
    }

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
      throw new Error(
        "Required parameter name was null or undefined when calling getPipeline."
      );
    }

    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined) {
      throw new Error(
        "Required parameter version was null or undefined when calling getPipeline."
      );
    }

    if (view !== undefined) {
      localVarQueryParameters["view"] = ObjectSerializer.serialize(
        view,
        "'VIEW_UNSPECIFIED' | 'BASIC' | 'FULL'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Sajariv4beta1Pipeline1;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Sajariv4beta1Pipeline1");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Retrieve a list of pipelines.
   * @summary List pipelines
   * @param collectionId The collection that owns this set of pipelines, e.g. &#x60;my-collection&#x60;.
   * @param pageSize The maximum number of pipelines to return. The service may return fewer than this value.  If unspecified, at most 50 pipelines are returned.  The maximum value is 1000; values above 1000 are coerced to 1000.
   * @param pageToken A page token, received from a previous [ListPipelines](/docs/api-reference#operation/ListPipelines) call.  Provide this to retrieve the subsequent page.  When paginating, all other parameters provided to [ListPipelines](/docs/api-reference#operation/ListPipelines) must match the call that provided the page token.
   * @param view The amount of information to include in each retrieved pipeline.   - VIEW_UNSPECIFIED: The default / unset value. The API defaults to the &#x60;BASIC&#x60; view.  - BASIC: Include basic information including type, name, version and description but not the full step configuration. This is the default value (for both [ListPipelines](/docs/api-reference#operation/ListPipelines) and [GetPipeline](/docs/api-reference#operation/GetPipeline)).  - FULL: Include the information from &#x60;BASIC&#x60;, plus full step configuration.
   */
  public async listPipelines(
    collectionId: string,
    pageSize?: number,
    pageToken?: string,
    view?: "VIEW_UNSPECIFIED" | "BASIC" | "FULL",
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: V4beta1ListPipelinesResponse;
  }> {
    const localVarPath =
      this.basePath +
      "/v4beta1/collections/{collection_id}/pipelines".replace(
        /{\w+}/,
        String(collectionId)
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling listPipelines."
      );
    }

    if (pageSize !== undefined) {
      localVarQueryParameters["page_size"] = ObjectSerializer.serialize(
        pageSize,
        "number"
      );
    }

    if (pageToken !== undefined) {
      localVarQueryParameters["page_token"] = ObjectSerializer.serialize(
        pageToken,
        "string"
      );
    }

    if (view !== undefined) {
      localVarQueryParameters["view"] = ObjectSerializer.serialize(
        view,
        "'VIEW_UNSPECIFIED' | 'BASIC' | 'FULL'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: V4beta1ListPipelinesResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(
              body,
              "V4beta1ListPipelinesResponse"
            );
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Set the default pipeline for a collection.  Every collection has a default `record` pipeline and a default `query` pipeline.  When a pipeline is required to complete an operation, it can be omitted from the request if a default pipeline has been set. When adding a record to a collection, the default `record` pipeline is used if none is provided. When querying a collection, the default `query` pipeline is used if none is provided.  Once a default pipeline has been set it cannot be cleared, only set to another pipeline.
   * @summary Set default pipeline
   * @param collectionId The collection to set the default query pipeline of, e.g. &#x60;my-collection&#x60;.
   * @param v4beta1SetDefaultPipelineRequest
   */
  public async setDefaultPipeline(
    collectionId: string,
    v4beta1SetDefaultPipelineRequest: V4beta1SetDefaultPipelineRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: object }> {
    const localVarPath =
      this.basePath +
      "/v4beta1/collections/{collection_id}:setDefaultPipeline".replace(
        /{\w+}/,
        String(collectionId)
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling setDefaultPipeline."
      );
    }

    // verify required parameter 'v4beta1SetDefaultPipelineRequest' is not null or undefined
    if (
      v4beta1SetDefaultPipelineRequest === null ||
      v4beta1SetDefaultPipelineRequest === undefined
    ) {
      throw new Error(
        "Required parameter v4beta1SetDefaultPipelineRequest was null or undefined when calling setDefaultPipeline."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        v4beta1SetDefaultPipelineRequest,
        "V4beta1SetDefaultPipelineRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body: object }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              body = ObjectSerializer.deserialize(body, "object");
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        }
      );
    });
  }
  /**
   * Set the default version for a given pipeline.  The default version of a pipeline allows you to refer to a pipeline without having to specify a version. This means you can change the pipeline version used for requests without having to change your code.
   * @summary Set default pipeline version
   * @param collectionId The collection that owns the pipeline to set the default version of, e.g. &#x60;my-collection&#x60;.
   * @param type The type of the pipeline to set the default version of, either &#x60;record&#x60; or &#x60;query&#x60;.
   * @param name The name of the pipeline to set the default version of, e.g. &#x60;my-pipeline&#x60;.
   * @param v4beta1SetDefaultVersionRequest
   */
  public async setDefaultVersion(
    collectionId: string,
    type: string,
    name: string,
    v4beta1SetDefaultVersionRequest: V4beta1SetDefaultVersionRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: object }> {
    const localVarPath =
      this.basePath +
      "/v4beta1/collections/{collection_id}/pipelines/{type}/{name}:setDefaultVersion"
        .replace(/{\w+}/, String(collectionId))
        .replace(/{\w+}/, String(type))
        .replace(/{\w+}/, String(name));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling setDefaultVersion."
      );
    }

    // verify required parameter 'type' is not null or undefined
    if (type === null || type === undefined) {
      throw new Error(
        "Required parameter type was null or undefined when calling setDefaultVersion."
      );
    }

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
      throw new Error(
        "Required parameter name was null or undefined when calling setDefaultVersion."
      );
    }

    // verify required parameter 'v4beta1SetDefaultVersionRequest' is not null or undefined
    if (
      v4beta1SetDefaultVersionRequest === null ||
      v4beta1SetDefaultVersionRequest === undefined
    ) {
      throw new Error(
        "Required parameter v4beta1SetDefaultVersionRequest was null or undefined when calling setDefaultVersion."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        v4beta1SetDefaultVersionRequest,
        "V4beta1SetDefaultVersionRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body: object }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              body = ObjectSerializer.deserialize(body, "object");
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        }
      );
    });
  }
}
