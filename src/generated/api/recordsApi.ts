/**
 * Search.io API
 * Search.io offers a search and discovery service with NeuralsearchÂ®, the world\'s first instant AI search technology. Businesses of all sizes use Search.io to build site search and discovery solutions that maximize e-commerce revenue, optimize on-site customer experience, and scale their online presence.  # Authentication <!-- ReDoc-Inject: <SecurityDefinitions> -->  # Rate limiting  The Search.io API employs a number of safeguards against bursts of incoming traffic to help maximize its stability. Users who send many requests in quick succession may see error responses that show up as HTTP status code `429`.  For the [UpsertRecord](/docs/api#operation/UpsertRecord) call, Search.io allows up to 175 write operations per second.  Treat these limits as maximums and don\'t generate unnecessary load. See [Handling limiting gracefully](/docs/api/#section/Rate-limiting/Handling-limiting-gracefully) for advice on handling `429`s.  We may reduce limits to prevent abuse.  ## Common causes and mitigations  Rate limiting can occur under a variety of conditions, but it\'s most common in these scenarios:  - Running a large volume of closely-spaced requests. Often this is part of a user\'s long-running reindex job. When engaging in these activities, you should try to control the request rate (see [Handling limiting gracefully](/docs/api/#section/Rate-limiting/Handling-limiting-gracefully)). - Running batch operations in parallel. Often [BatchUpsertRecords](/docs/api#operation/BatchUpsertRecords) is used as part of a user\'s long-running reindex job. A batch of records of size `N` passed to [BatchUpsertRecords](/docs/api#operation/BatchUpsertRecords) is counted as `N` [UpsertRecord](/docs/api#operation/UpsertRecord) calls for the purposes of rate limiting, as opposed to a single call. Treat batch API calls as a convenience rather than a way to get more write throughput.  ## Handling limiting gracefully  A basic technique for integrations to gracefully handle limiting is to watch for `429` HTTP status codes and build in a retry mechanism. The retry mechanism should follow an exponential backoff schedule to reduce request volume when necessary. We also recommend building some randomness into the backoff schedule to avoid a [thundering herd effect](https://en.wikipedia.org/wiki/Thundering_herd_problem).
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: support@search.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from "request";
import http from "http";

/* tslint:disable:no-unused-locals */
import { BatchUpdateRecordsRequest } from "../model/batchUpdateRecordsRequest";
import { BatchUpdateRecordsResponse } from "../model/batchUpdateRecordsResponse";
import { BatchUpsertRecordsRequest } from "../model/batchUpsertRecordsRequest";
import { BatchUpsertRecordsResponse } from "../model/batchUpsertRecordsResponse";
import { DeleteRecordRequest } from "../model/deleteRecordRequest";
import { GetRecordRequest } from "../model/getRecordRequest";
import { UpdateRecordRequest } from "../model/updateRecordRequest";
import { UpsertRecordRequest } from "../model/upsertRecordRequest";
import { UpsertRecordResponse } from "../model/upsertRecordResponse";

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from "../model/models";
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from "../model/models";

import { HttpError, RequestFile } from "./apis";

let defaultBasePath = "https://api.search.io";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RecordsApiApiKeys {}

export class RecordsApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    BasicAuth: new HttpBasicAuth(),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(username: string, password: string, basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      this.username = basePathOrUsername;
      this.password = password;
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: RecordsApiApiKeys, value: string) {
    (this.authentications as any)[RecordsApiApiKeys[key]].apiKey = value;
  }

  set username(username: string) {
    this.authentications.BasicAuth.username = username;
  }

  set password(password: string) {
    this.authentications.BasicAuth.password = password;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   * The batch version of the [UpdateRecord](/docs/api#operation/UpdateRecord) call.  You cannot run batches in parallel. Your code must wait for previous calls to `BatchUpdateRecords` to complete before making subsequent calls.  A maximum of 200 records can be updated in a batch.
   * @summary Batch update records
   * @param collectionId The collection that contains the records to update, e.g. &#x60;my-collection&#x60;.
   * @param batchUpdateRecordsRequest
   * @param accountId The account that owns the collection, e.g. &#x60;1618535966441231024&#x60;.
   */
  public async batchUpdateRecords(
    collectionId: string,
    batchUpdateRecordsRequest: BatchUpdateRecordsRequest,
    accountId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BatchUpdateRecordsResponse;
  }> {
    const localVarPath =
      this.basePath +
      "/v4/collections/{collection_id}/records:batchUpdate".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling batchUpdateRecords."
      );
    }

    // verify required parameter 'batchUpdateRecordsRequest' is not null or undefined
    if (
      batchUpdateRecordsRequest === null ||
      batchUpdateRecordsRequest === undefined
    ) {
      throw new Error(
        "Required parameter batchUpdateRecordsRequest was null or undefined when calling batchUpdateRecords."
      );
    }

    localVarHeaderParams["Account-Id"] = ObjectSerializer.serialize(
      accountId,
      "string"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        batchUpdateRecordsRequest,
        "BatchUpdateRecordsRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BatchUpdateRecordsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "BatchUpdateRecordsResponse"
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * The batch version of the [UpsertRecord](/docs/api#operation/UpsertRecord) call.  You cannot run batches in parallel. Your code must wait for previous calls to `BatchUpsertRecords` to complete before making subsequent calls.  A maximum of 200 records can be upserted in a batch.
   * @summary Batch upsert records
   * @param collectionId The collection to upsert the records in, e.g. &#x60;my-collection&#x60;.
   * @param batchUpsertRecordsRequest
   * @param accountId The account that owns the collection, e.g. &#x60;1618535966441231024&#x60;.
   */
  public async batchUpsertRecords(
    collectionId: string,
    batchUpsertRecordsRequest: BatchUpsertRecordsRequest,
    accountId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: BatchUpsertRecordsResponse;
  }> {
    const localVarPath =
      this.basePath +
      "/v4/collections/{collection_id}/records:batchUpsert".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling batchUpsertRecords."
      );
    }

    // verify required parameter 'batchUpsertRecordsRequest' is not null or undefined
    if (
      batchUpsertRecordsRequest === null ||
      batchUpsertRecordsRequest === undefined
    ) {
      throw new Error(
        "Required parameter batchUpsertRecordsRequest was null or undefined when calling batchUpsertRecords."
      );
    }

    localVarHeaderParams["Account-Id"] = ObjectSerializer.serialize(
      accountId,
      "string"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        batchUpsertRecordsRequest,
        "BatchUpsertRecordsRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: BatchUpsertRecordsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "BatchUpsertRecordsResponse"
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Delete a record with the given key.  If you receive \"service unavailable\" errors, the collection may be in read only mode. This is indicated by a `COLLECTION_READ_ONLY` reason inside the error details. The following snippet shows the JSON response for a collection read only error.  ```json {   \"code\": 14,   \"message\": \"read only\",   \"details\": [     {       \"@type\": \"type.googleapis.com/google.rpc.ErrorInfo\",       \"reason\": \"COLLECTION_READ_ONLY\"     }   ] } ```  If you encounter this error you should retry your call. Your app can use the `Retry-After` HTTP header to know when to retry.
   * @summary Delete record
   * @param collectionId The collection that contains the record to delete, e.g. &#x60;my-collection&#x60;.
   * @param deleteRecordRequest
   * @param accountId The account that owns the collection, e.g. &#x60;1618535966441231024&#x60;.
   */
  public async deleteRecord(
    collectionId: string,
    deleteRecordRequest: DeleteRecordRequest,
    accountId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: any }> {
    const localVarPath =
      this.basePath +
      "/v4/collections/{collection_id}/records:delete".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling deleteRecord."
      );
    }

    // verify required parameter 'deleteRecordRequest' is not null or undefined
    if (deleteRecordRequest === null || deleteRecordRequest === undefined) {
      throw new Error(
        "Required parameter deleteRecordRequest was null or undefined when calling deleteRecord."
      );
    }

    localVarHeaderParams["Account-Id"] = ObjectSerializer.serialize(
      accountId,
      "string"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        deleteRecordRequest,
        "DeleteRecordRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body: any }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                body = ObjectSerializer.deserialize(body, "any");
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        }
      );
    });
  }
  /**
   * Retrieve a record with the given key.
   * @summary Get record
   * @param collectionId The collection that contains the record to retrieve, e.g. &#x60;my-collection&#x60;.
   * @param getRecordRequest
   * @param accountId The account that owns the collection, e.g. &#x60;1618535966441231024&#x60;.
   */
  public async getRecord(
    collectionId: string,
    getRecordRequest: GetRecordRequest,
    accountId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: object }> {
    const localVarPath =
      this.basePath +
      "/v4/collections/{collection_id}/records:get".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling getRecord."
      );
    }

    // verify required parameter 'getRecordRequest' is not null or undefined
    if (getRecordRequest === null || getRecordRequest === undefined) {
      throw new Error(
        "Required parameter getRecordRequest was null or undefined when calling getRecord."
      );
    }

    localVarHeaderParams["Account-Id"] = ObjectSerializer.serialize(
      accountId,
      "string"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(getRecordRequest, "GetRecordRequest"),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body: object }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                body = ObjectSerializer.deserialize(body, "object");
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        }
      );
    });
  }
  /**
   * Add or update specific fields within a record with the given values. The updated record is returned in the response.  To replace all fields in a record, you should use the [UpsertRecord](/docs/api#operation/UpsertRecord) call.  Note that the update record call cannot be used to add or update indexed or unique fields. For this case use the [UpsertRecord](/docs/api#operation/UpsertRecord) call.  If you receive \"service unavailable\" errors, the collection may be in read only mode. This is indicated by a `COLLECTION_READ_ONLY` reason inside the error details. The following snippet shows the JSON response for a collection read only error.  ```json {   \"code\": 14,   \"message\": \"read only\",   \"details\": [     {       \"@type\": \"type.googleapis.com/google.rpc.ErrorInfo\",       \"reason\": \"COLLECTION_READ_ONLY\"     }   ] } ```  If you encounter this error you should retry your call. Your app can use the `Retry-After` HTTP header to know when to retry.
   * @summary Update record
   * @param collectionId The collection that contains the record to update, e.g. &#x60;my-collection&#x60;.
   * @param updateRecordRequest
   * @param accountId The account that owns the collection, e.g. &#x60;1618535966441231024&#x60;.
   */
  public async updateRecord(
    collectionId: string,
    updateRecordRequest: UpdateRecordRequest,
    accountId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: object }> {
    const localVarPath =
      this.basePath +
      "/v4/collections/{collection_id}/records:update".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling updateRecord."
      );
    }

    // verify required parameter 'updateRecordRequest' is not null or undefined
    if (updateRecordRequest === null || updateRecordRequest === undefined) {
      throw new Error(
        "Required parameter updateRecordRequest was null or undefined when calling updateRecord."
      );
    }

    localVarHeaderParams["Account-Id"] = ObjectSerializer.serialize(
      accountId,
      "string"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateRecordRequest,
        "UpdateRecordRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body: object }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                body = ObjectSerializer.deserialize(body, "object");
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        }
      );
    });
  }
  /**
   * If the record does not exist in the collection it is inserted. If it does exist it is updated.  If no pipeline is specified, the default record pipeline is used to process the record.  If the record is inserted, the response contains the key of the inserted record. You can use this if you need to retrieve or delete the record. If the record is updated, the response does not contain a key. Callers can use this as a signal to determine if the record is inserted/created or updated.  For example, to add a single product from your ecommerce store to a collection, use the following call:  ```json {   \"pipeline\": {     \"name\": \"my-pipeline\",     \"version\": \"1\"   },   \"record\": {     \"id\": \"54hdc7h2334h\",     \"name\": \"Smart TV\",     \"price\": 1999,     \"brand\": \"Acme\",     \"description\": \"...\",     \"in_stock\": true   } } ```  If you receive \"service unavailable\" errors, the collection may be in read only mode. This is indicated by a `COLLECTION_READ_ONLY` reason inside the error details. The following snippet shows the JSON response for a collection read only error.  ```json {   \"code\": 14,   \"message\": \"read only\",   \"details\": [     {       \"@type\": \"type.googleapis.com/google.rpc.ErrorInfo\",       \"reason\": \"COLLECTION_READ_ONLY\"     }   ] } ```  If you encounter this error you should retry your call. Your app can use the `Retry-After` HTTP header to know when to retry.
   * @summary Upsert record
   * @param collectionId The collection to upsert the record in, e.g. &#x60;my-collection&#x60;.
   * @param upsertRecordRequest
   * @param accountId The account that owns the collection, e.g. &#x60;1618535966441231024&#x60;.
   */
  public async upsertRecord(
    collectionId: string,
    upsertRecordRequest: UpsertRecordRequest,
    accountId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: UpsertRecordResponse }> {
    const localVarPath =
      this.basePath +
      "/v4/collections/{collection_id}/records:upsert".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling upsertRecord."
      );
    }

    // verify required parameter 'upsertRecordRequest' is not null or undefined
    if (upsertRecordRequest === null || upsertRecordRequest === undefined) {
      throw new Error(
        "Required parameter upsertRecordRequest was null or undefined when calling upsertRecord."
      );
    }

    localVarHeaderParams["Account-Id"] = ObjectSerializer.serialize(
      accountId,
      "string"
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        upsertRecordRequest,
        "UpsertRecordRequest"
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (
      this.authentications.BasicAuth.username &&
      this.authentications.BasicAuth.password
    ) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpsertRecordResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "UpsertRecordResponse");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
