/**
 * Search.io API
 * Search.io offers a search and discovery service with NeuralsearchÂ®, the world\'s first instant AI search technology. Businesses of all sizes use Search.io to build site search and discovery solutions that maximize e-commerce revenue, optimize on-site customer experience, and scale their online presence.  # Authentication <!-- ReDoc-Inject: <SecurityDefinitions> -->  # Rate limiting  The Search.io API employs a number of safeguards against bursts of incoming traffic to help maximize its stability. Users who send many requests in quick succession may see error responses that show up as HTTP status code `429`.  For the [UpsertRecord](/docs/api#operation/UpsertRecord) call, Search.io allows up to 175 write operations per second.  Treat these limits as maximums and don\'t generate unnecessary load. See [Handling limiting gracefully](/docs/api/#section/Rate-limiting/Handling-limiting-gracefully) for advice on handling `429`s.  We may reduce limits to prevent abuse.  ## Common causes and mitigations  Rate limiting can occur under a variety of conditions, but it\'s most common in these scenarios:  - Running a large volume of closely-spaced requests. Often this is part of a user\'s long-running reindex job. When engaging in these activities, you should try to control the request rate (see [Handling limiting gracefully](/docs/api/#section/Rate-limiting/Handling-limiting-gracefully)). - Running batch operations in parallel. Often [BatchUpsertRecords](/docs/api#operation/BatchUpsertRecords) is used as part of a user\'s long-running reindex job. A batch of records of size `N` passed to [BatchUpsertRecords](/docs/api#operation/BatchUpsertRecords) is counted as `N` [UpsertRecord](/docs/api#operation/UpsertRecord) calls for the purposes of rate limiting, as opposed to a single call. Treat batch API calls as a convenience rather than a way to get more write throughput.  ## Handling limiting gracefully  A basic technique for integrations to gracefully handle limiting is to watch for `429` HTTP status codes and build in a retry mechanism. The retry mechanism should follow an exponential backoff schedule to reduce request volume when necessary. We also recommend building some randomness into the backoff schedule to avoid a [thundering herd effect](https://en.wikipedia.org/wiki/Thundering_herd_problem).
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: support@search.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { RequestFile } from "./models";
import { Banner } from "./banner";
import { PromotionExclusion } from "./promotionExclusion";
import { PromotionFilterBoost } from "./promotionFilterBoost";
import { PromotionFilterCondition } from "./promotionFilterCondition";
import { PromotionPin } from "./promotionPin";
import { PromotionRangeBoost } from "./promotionRangeBoost";

/**
 * Promotion contains a trigger, determining which searches it should be active for, and a list of alterations that should be made to search results when it is active.
 */
export class Promotion {
  /**
   * The banners that are injected into the result set when the promotion is triggered.
   */
  "banners"?: Array<Banner>;
  /**
   * The ID of the collection that owns this promotion.
   */
  "collectionId"?: string;
  /**
   * A condition expression applied to a search request that determines which searches the promotion is active for.  For example, to apply the promotion\'s pins and boosts whenever a user searches for \'shoes\' set condition to `q = \'shoes\'`.
   */
  "condition": string;
  /**
   * The time the promotion was created.
   */
  "createTime"?: Date;
  /**
   * If disabled, the promotion is never triggered.
   */
  "disabled"?: boolean;
  /**
   * The promotion\'s display name.
   */
  "displayName": string;
  /**
   * If specified, the promotion is considered disabled after this time.
   */
  "endTime"?: Date;
  /**
   * The records to exclude from search results, if the promotion is enabled.
   */
  "exclusions"?: Array<PromotionExclusion>;
  /**
   * The filter boosts to apply to searches, if the promotion is enabled.
   */
  "filterBoosts"?: Array<PromotionFilterBoost>;
  /**
   * The conditions applied to the filters passed from the user. A query must match at least one of these in order to trigger the promotion. A filter condition is comprised of a set of filters of the form `field = value` and matches a query if all of those filters are present in the query.  For example, a query with the filter `productType = \'shirt\' AND size = \'medium\'` triggers a promotion with the filter condition `productType = \'shirt\'`, but not one with both `productType = \'shirt\', and `size = \'small\'`.
   */
  "filterConditions"?: Array<PromotionFilterCondition>;
  /**
   * The promotion\'s ID.
   */
  "id"?: string;
  /**
   * The items to fix to specific positions in the search results.
   */
  "pins"?: Array<PromotionPin>;
  /**
   * The range boosts to apply to searches, if the promotion is enabled.
   */
  "rangeBoosts"?: Array<PromotionRangeBoost>;
  /**
   * If specified, the promotion is considered disabled before this time.
   */
  "startTime"?: Date;
  /**
   * The time the promotion was last updated.
   */
  "updateTime"?: Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "banners",
      baseName: "banners",
      type: "Array<Banner>",
    },
    {
      name: "collectionId",
      baseName: "collection_id",
      type: "string",
    },
    {
      name: "condition",
      baseName: "condition",
      type: "string",
    },
    {
      name: "createTime",
      baseName: "create_time",
      type: "Date",
    },
    {
      name: "disabled",
      baseName: "disabled",
      type: "boolean",
    },
    {
      name: "displayName",
      baseName: "display_name",
      type: "string",
    },
    {
      name: "endTime",
      baseName: "end_time",
      type: "Date",
    },
    {
      name: "exclusions",
      baseName: "exclusions",
      type: "Array<PromotionExclusion>",
    },
    {
      name: "filterBoosts",
      baseName: "filter_boosts",
      type: "Array<PromotionFilterBoost>",
    },
    {
      name: "filterConditions",
      baseName: "filter_conditions",
      type: "Array<PromotionFilterCondition>",
    },
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "pins",
      baseName: "pins",
      type: "Array<PromotionPin>",
    },
    {
      name: "rangeBoosts",
      baseName: "range_boosts",
      type: "Array<PromotionRangeBoost>",
    },
    {
      name: "startTime",
      baseName: "start_time",
      type: "Date",
    },
    {
      name: "updateTime",
      baseName: "update_time",
      type: "Date",
    },
  ];

  static getAttributeTypeMap() {
    return Promotion.attributeTypeMap;
  }
}
